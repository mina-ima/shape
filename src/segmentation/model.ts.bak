// src/segmentation/model.ts
import * as ort from "onnxruntime-web";
import { resolveU2NetModelUrl } from "@/models/loadU2Net"; // パスエイリアスが無い場合は相対パスに変更

let session: ort.InferenceSession | undefined;

/**
 * ONNX モデルを読み込み、共有セッションを初期化します。
 * 既に初期化済みなら同じセッションを返します。
 * - modelPath 未指定時は /models/u2netp.onnx を自動解決（404回避）
 */
export async function loadOnnxModel(
  modelPath?: string,
  options?: Partial<ort.InferenceSession.SessionOptions> & Record<string, any>
): Promise<ort.InferenceSession> {
  if (session) return session;

  // 未指定ならユーティリティで解決（/models/u2netp.onnx）
  const selected =
    modelPath ?? (await resolveU2NetModelUrl("u2netp", "/models"));

  session = await ort.InferenceSession.create(selected, {
    executionProviders: ["wasm"],
    graphOptimizationLevel: "all",
    ...(options ?? {}),
  });

  // テストがこのログを期待します
  console.log("ONNX session loaded successfully.");
  return session;
}

/** セッションを破棄（テストリセット用） */
export function resetOnnxSession() {
  session = undefined;
}

/** 内部用：必要ならロードしてセッションを返す */
async function ensureSession(modelPath?: string): Promise<ort.InferenceSession> {
  if (!session) {
    await loadOnnxModel(modelPath); // 未指定でも自動解決される
  }
  return session!;
}

/**
 * 推論を実行します。セッション未初期化の場合は opts.modelPath が指定されていれば自動ロードします。
 */
export async function runOnnxInference(
  inputs: Record<string, ort.Tensor>,
  opts?: { modelPath?: string }
) {
  const s = await ensureSession(opts?.modelPath);

  // feeds を浅いコピーで組み立て（型の明示）
  const feeds: Record<string, ort.Tensor> = {};
  for (const k of Object.keys(inputs)) {
    feeds[k] = inputs[k];
  }

  const results = await s.run(feeds);
  return results;
}
